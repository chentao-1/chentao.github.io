什么是springIOC，IOC是依赖注入，控制反转
依赖注入，控制反转？what？？？？？？？？？听起来好抽象啊，到底什么是依赖注入和控制反转呢
这就要从软件的设计原则说起了，在软件设计原则中有这么一条，叫做开闭原则，开闭原则即是，对扩展开放，对修改关闭
对扩展开放，对修改关闭怎么做呢，需要定义良好的接口，然后利用利用Java的多态：一个接口可以有若干个实现类
利用接口，使用多态，这是解决了一部分问题！！！
那么问题来了，如果我的若干个实现类或者子类需要和其他代码协作，代码如下：
new A
new B
new C
new ...
如果说执行软件的开闭原则，解决了软件架构的扩展性和可维护性，那么
上述代码，解决不了代码之间的关联性，每次都需要new ...
那么怎么解决这个问题呢
我可不可以定义一个容器，在需要这个对象的时候给他一个对象，因为代码只是传输数据的一个媒介而已，代码执行完，随机从内存中消失
其实对象就是一个数据传递或者中转的媒介
大家都知道Java的反射机制，如果定义一个类，并给定这个类的类路径我们就可以获得该对象
如果把获取对象这个过程通过一个手段把他抽象出来，在需要的时候提供给他使用，使用完后销毁
是不是代码中就少了
new a 
new b
...
那么代码的可读性，可维护性，拓展性马上增强了
那么这个代码到底如何实现呢？
首先加载配置文件获得类路径
然后通过反射创建该对象提供给使用者

其实这还远远不够，因为在我们现在框架运行中，大多都是代理对象
为什么呢


因为只有代理对象才能进行增强，动态的去修改代码
才能进一步实现AOP ==功能

spring中有一个代理工厂类
在初始化初期，代理工厂通过传进来的真实对象创建了无数的代理对象维持在容器中
这也是为什么 能实现AOP
你写一个切面就动态的切进去的原因
